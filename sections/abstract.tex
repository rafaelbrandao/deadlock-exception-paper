\begin{abstract}

Concurrent programming has been challenging developers over decades with their bugs, as they are very difficult to find and reproduce. Deadlocks are very common types of concurrency bugs, happening when locks are used to keep critical zones safe from multiple threads interference. However, even when a deadlock bug is reproduced, it's very difficult to clearly say if there's an actual deadlock or if the application is slow or hanging for a different reason. To solve this problem, we believe that if deadlocks were handled as exceptions, programmers would accurately identify them faster, reducing the amount of time until it is fixed. Some programming languages, such as Haskell and Go, already provides this concept for specific cases of deadlocks. In this work, we've searched for deadlock bugs in three different open-source projects and we confirmed which type of deadlock is the most popular: the one where only two threads are stuck waiting circularly for each other. Then, we've modified Java's \emph{ReentrantLock} implementation to throw a runtime exception when a classic deadlock happens and provided a sketch of a proof to explain why it should work. Finally, we've measured how it positively affects programmers's speed to identify bugs in the code and their accuracy on why a deadlock happened.

\keywords{lock, concurrency bugs, deadlock, runtime exception}
\end{abstract}