\chapter{Bug Reports}

Previous study have noticed some interesting pattern about deadlock concurrency bugs: the vast majority of deadlocks only involved at most two resources (30 ouf ot 31 bugs) \cite{lu}, only one bug was triggered by three threads waiting for three resources circularly. Since we suspect deadlocks with two resources were indeed more common in practice, we've decided to investigate this finding with a bigger sample of bug reports related to deadlock.

In this chapter, we'll present our bug reports study: how we've collected the samples, how we've analysed the data and what results we've found.

\section{Sample Collection}

We've chosen three open source projects which used Java as main programming language and made use of concurrent programming. The first project we've chosen was Lucene: a text search engine library that can be used along many applications, where concurrent programming was used to deliver high performance. The second project was Eclipse: one of the most popular IDE for java developers. The third project was OpenJDK: open-source implementation of the Java Platform. These projects have vast bug report repositories that we could use to search for reports and developers had the habit of commenting details about the bug and the solution to fix it on the bug report itself which was very important in our study.

We have initially searched in each repository for the keyword \emph{deadlock}, and we've collected 541 bug reports in total. Each project had a different bug repository, so we've changed slightly to find relevant bug reports.

In Lucene, we've searched for bugs matching the word "deadlock" anywhere in the bug report (i.e. in summary or in comments), in module "lucene-core" with issue type as "bug", where status was "closed", as we are focusing on bugs that were resolved. From this search, we've found 27 bugs\footnote{http://goo.gl/DhVI3t}.

In Eclipse, we've searched for "deadlock" in summary, where resolution was set to "fixed" and status was set to "resolved". From this search, we've found 406 bugs\footnote{http://goo.gl/qQnrEm}.

In OpenJDK, we've searched the word "deadlock" in summary, in module "JDK" with issue type as "bug", where resolution was set to "fixed", status was "resolved". From this search, we've found 108 bugs\footnote{http://goo.gl/xYFfsO}.

Assuming normal distribution in bug reports population, we've calculated the minimal size of the sample where we could achieve 95\% of confidence level and 5\% sampling error, setting response distribution to 50\% so we could find the biggest sample size\footnote{More about 'response distribution' in http://www.raosoft.com/samplesize.html}. We've found minimal size as 225, so we've created a random sample of 225 bugs out of all bugs we've found. In appendix we provide the code we've used to calculate the sample size.

\section{Data Labeling}

We've merged all bug reports of our random sample in one single table where the prefix of each bug number could be either \emph{LUCENE}, \emph{ECLIPSE} or \emph{JDK}, followed by the bug number inside its own repository. Then we've added a category label field which is a character between "A" and "D" that we would set after manual inspections and following some criterias that we will present next. Besides that, we've added other fields in this table, such as \emph{"TYPE"}, \emph{"# of THREADS"}, \emph{"# of RESOURCES"} and \emph{"NOTES"}. The final version of this table\footnote{http://goo.gl/zNsIGz} also contains \emph{"TIME (HOURS)"} and \emph{"COMMENTS"} which were extracted automatically from the bug reports.

\subsection{Field "CATEGORY"}

This is the most important field, as we want to be able to identify what kind of deadlock this bug represents, in case it is indeed deadlock related. We have four different values for this field, and they must be one of the following:

\emph{A:} We are confident this a resource deadlock. We should be able to provide a short explanation of how the bug occurs, which or how many threads are involved and how many locks are involved in this bug.

\emph{B:} We are confident this is not a resource deadlock, so it must be a communication deadlock. It might be a lost notify/signal bug. We should be able to identify if this is a lost notify/signal or have clear evidence this is not a resource deadlock (adding a note whenever possible).

\emph{C:} We are confident this is a false-positive for "deadlock" search. The term was used as a synonym of "hang" or "infinite loop", or to refer to another deadlock bug. In some cases, it is possible that a bug refers to another bug which was fixing a deadlock, so the initial bug may not be deadlock-related and just fix a regression for another bug (which could be deadlock-related). In other words, this is not a deadlock bug at all.

\emph{D:} We are not confident whether this is a resource deadlock or a communication deadlock, or even if this is a false-positive for deadlock. There's not enough information in the bug report, or the information is just inconclusive. Since we are not experts on any of these repositories, it's hard to classify for sure in another category.

Category A will be only assigned when there's a clear comment in the bug explaining what threads and which resources are involved or other evidences can clarify without doubt how many threads and lock resources are involved. In a few cases, the explanation is not fully clear but the attachment provides a clear thread dump showing which threads are involved and which locks each one is holding and waiting for, so we can also use this information to make a final decision.

Category B can be classified by also looking into source code changes when we are almost clear about its category: if the patch changes areas of the code where a notifyAll is added or moved, then it is most likely a category B indeed. Sometimes it is just a semantic deadlock where one threads is in an infinite loop waiting for others to finish and other threads are stuck waiting to acquire a lock the first thread already acquired; in this case, we also understand as a communication deadlock: the "message" which the first thread have been waiting is whether the other threads have finished.

Category C is often easy to classify since the bug often explains another kind of bug and then cites the term "deadlock" as a synonym for "hang". As stated previously, if this bug only refers to another bug (such as a regression) that mentions deadlock or fixes a deadlock, then this bug might not be a deadlock by itself, just a fix of another previous fix, which would also fall into this category.

Category D is for all other bugs which could not be classified as either A, B or C.

\subsubsection{Reviewing Protocol:} 

In order to minimize error on our classification, we've created a protocol that every reviewer should follow, which basically describes how data should be analysed for a certain bug. For example, sometimes a bug points to another one as a duplicate, those links should be used if the initial bug is not clear enough. In order to organize how the review is executed, we should roughly follow these steps:

1. Look at bug title and bug main description (usually the first comment). Sometimes the reporter have an idea of how the bug occurs and which threads are involved, so this is a big help.

2. Look at further comments and see if someone understood this bug completely. Someone must have provided a reasonable explanation of how this bug occurs. If the category is already clear, then finish these steps; otherwise proceed.

3. If available, look at the patches (specially the final patch) and what changes have been made. If uncertain about this bug being in category B and the patch either moves or adds a notifyAll call, then it most likely is a category B bug. If this is not the case, then proceed.

4. If available, look at the related bugs or duplicates. It's often to find an initial bug that is unclear but which points out to a duplicate that have been largely discussed and is clear. Restart from step 1 for each of those related bugs. If a category was not assigned yet, then proceed.

5. See other attachments if available, like text files with thread dumps or stack traces. If they provide enough information to clarify which category it is, then assign a category to it, otherwise proceed.

6. Classify this bug in the category D.

\subsection{Fields "\# of THREADS" and "\# of RESOURCES"}

Whenever possible, the reviewer should state the number of threads and resources involved, even if this is in the category B. If it's unknown how many resources but it is clear how many threads are involved, then only one of them should be filled and the other field should remain blank.

\subsection{Field "TYPE"}

This field is just an annotation and it should be used to specify what kinds of resources a certain bug use. For example if there are two threads and they're in a circular deadlock, then this field should be locks/synchronized, or if you are sure that explicit locks were used for both, then just locks is enough, or if only synchronized blocks/methods are involved, then just synchronized.

The symbol + indicates a separation between threads, so for example "locks + wait" means that one thread holds a lock and the other waits". As this may be confusing, an easy replacement would be to use the "notes" field instead and write down what was found about this bug.

\subsection{Field "NOTES"}

This field was encouraged to be used specially to remind other reviewers in the future of how the conclusion was made for cases where it was tricky to choose the category.

\section{Data Analysis}

Since our focus is on resource deadlocks, we want to understand how many resource deadlock bugs did involve 2 threads and 2 resources, so we will discard bugs in B and C category. In the worse case scenario, all bugs in category D are resource deadlocks and does not involve simply 2 threads and 2 resources. As we are being conservative in our analysis, in the worse case scenario we have the following:

\begin{equation}
bugs\_ratio = \frac{ bugs(A, threads=2, resources=2) }{ bugs(A) + bugs(D) } \; .
\end{equation}

In that equation, \emph{bugs(...)} returns the number of bug reports that matches the parameters. Thus $bugs\_ratio$ is the worse case scenario of how often deadlock bugs are the classic case. If we want to look at the best case scenario, then all bugs classified in D category must also be classic deadlocks. The numbers we've found are 54.7\% in the worse case and 95.29\% on the best case. From all resource deadlocks we've found (in category A), 92.07\% (93 out of 101) were classic deadlocks. We provide the script that analyse this data in the appendix section.

\begin{table}
\begin{center}
\caption{Bug Reports Classification.}
\begin{tabular}{|l|l|}
\hline
Category & Number of Bugs \\
\hline
A & 101 \\   
B & 32 \\
C & 23 \\
D & 69 \\
\hline
\end{tabular}
\end{center}
\end{table}

However our conservative analysis may also be too unrealistic. If the distribution of bugs in D follows the proportions we've found for A, B and C, and the distribution of classic deadlocks also follows the one we've found, we can classify all bugs in D and remove this group completely: 45 bugs would be in A where 92.07\% of them (that is, 41) are classic deadlocks, 14 bugs would be in B, and 10 bugs would be in C.

Running the same equation defined previously but now with $bugs(D) = 0$ and the other groups sizes updated, we find 91.7\% of resource deadlocks involved 2 threads and 2 locks only.



