\begin{abstract}
Deadlocks are a common type of concurrency bug. %that occurs when multiple threads wait for each other to release an acquired resource while they are, themselves, holding resources they have previously acquired. 
When a deadlock occurs, it is difficult to clearly determine whether there is an actual deadlock or if the application is slow or hanging due to a different reason. It is also difficult to establish the cause of the deadlock. In general, developers deal with deadlocks by using analysis tools, introducing application-specific deadlock detection mechanisms, or simply by using techniques to avoid the occurrence of deadlocks by construction. In this paper we propose a different approach. We believe that if deadlocks manifest at runtime, as exceptions, programmers will be able to identify these deadlocks in an accurate and timely manner. We leverage two insights to make this practical: (i) most deadlocks occurring in real systems involve only two threads acquiring two locks (TTTL deadlocks); and (ii) it's possible to detect TTTL deadlocks efficiently enough for most practical systems. We conducted a study on bug reports and found that more than 90\%  of identified deadlocks were indeed TTTL. We extended Java's {\tt ReentrantLock} class to detect TTTL deadlocks and measured the performance overhead of this approach with a conservative benchmark. For applications whose execution time is not dominated by locking, the overhead is low. Empirical usability evaluation in two experiments showed that students finished tasks faster using the proposed approach and, in one of the experiments were also more accurate. 
\keywords{deadlock, concurrency, exception handling, empirical studies}
\end{abstract}