\section{Related Work}

From many deadlock detection algorithms we saw, Sanmati \cite{sammati} and its successor Serenity \cite{serenity} were the most similar to our work,
as they were dynamic analysis tools capable of detecting deadlocks at runtime and requiring no code changes to work.
But the main differences were: instead of providing exceptions, they recovered from deadlocks by discarding changes to memory done
inside critical sections during a rollback operation; lastly, it would only work for threaded applications that used pthreads interface.
However these two promising approaches had several limitations \cite{pyla}:
(i) rollback of acquired locks and all its related memory changes added high runtime overhead;
(ii) not all types of memory can be recovered in a rollback, like non-idompotent actions (i.e. I/O, semaphores, condition signals, etc.) and shared libraries state.
We believe these are hard limitations to overcome and we think our approach to throw deadlock exception gives more advantages in practice.