\section{Introduction}

Real-world applications use concurrency to do computation in parallel with multiple threads/processes taking more advantage of multicore processors. Unfortunately, concurrent code is difficult to write correctly, as it is well documented in \cite{lu}, and a very common mistake when using locks is known as deadlock.
Deadlocks manifest when threads are waiting each other in a cycle, where each thread is waiting for another thread to release its desired lock, in a never-ending wait.
Although we have two types of deadlocks, resource deadlocks and communication deadlocks \cite{singhal} \cite{knapp}, in this work, as other studies did before \cite{mcsdk} \cite{magicfuzzer}, our focus is on resource deadlocks. From now on, whenever the term \emph{deadlock} is used we implicitly mean {\bf resource deadlocks}.

Different from previous deadlock detection studies, we believe deadlocks should not fail silently but instead they should be signaled as exceptions in programming languages. Rather than trying to detect them when explicitly requested for a deadlock analysis, programs should instead be written in such a way that they can either handle the deadlock when it happens or just show the error in the output in order to allow easy identification of bugs. Some programming languages such as Haskell and Go already contain some kind of deadlock exception for very particular cases, and for this study, our proposed deadlock algorithm have focused on what we found to be the most common type of deadlock: between two threads and two locks (TTTL deadlocks).

Our main goals in this study are: to show how to detect TTTL deadlocks without extra atomic operations, also providing a lightweight implementation of deadlock exceptions that can seamlessly run on top of Java OpenJDK; to evaluate the runtime overhead of such implementation; and, lastly, to understand the benefits of such exceptions in programming languages by evaluating how the speed and accuracy of bug identification are affected. We start this paper by describing our bug reports study where we found TTTL deadlocks were the most common type of deadlock. Then we move forward to describe how and why the deadlock algorithm works for TTTL deadlocks. Then we present our evaluation for both usability and performance.





