\section{Introduction}

Real-world applications use concurrency to do computation in parallel with multiple threads/processes taking more advantage of multicore processors. Unfortunately, concurrent code is difficult to write correctly, as it is well documented~\cite{lu}. Deadlocks are a very common type of error in concurrent systems~\cite{lu}.
Deadlocks manifest when threads are waiting each other in a cycle, where each thread is waiting for another thread to release its desired lock. This produces a never-ending wait.
Although there are two well-documented types of deadlocks, resource deadlocks and communication deadlocks~\cite{singhal}\cite{knapp}, in this work our focus is on resource deadlocks, e.g., deadlocks that stem from threads attempting to obtain exclusive access to resources, and whenever the term \emph{deadlock} is used we implicitly mean resource deadlock.

In practice, developers employ a number of approaches to deal with deadlocks: (i) static program analyses \cite{marino}\cite{dawson}\cite{vivek}\cite{williams}; (ii) dynamic program analyses \cite{mcsdk}\cite{magicfuzzer}\cite{sammati}\cite{rx}; (iii) application-specific deadlock detection infrastructures \cite{orderedlock}; (iv) techniques to guarantee the absence of deadlocks by construction \cite{marino}; (v) model checking \cite{havelund}. The first two approaches are known to be heavyweight. In addition, the former often produces many false positives. The third approach has limited applicability and often imposes a high runtime overhead. The fourth approach has a low cost but cannot be employed in cases where it is not feasible to order lock acquisitions nor use non-blocking locking primitives. Finally, model checking is a powerful solution but has limited scalability when applied in the context of real programs. It also has limited generality, since some programs with side effects simply cannot be model checked.  

In this paper we advocate an approach that complements the aforementioned ones. In summary, we believe deadlocks should not fail silently but instead their occurrence  should be signaled as exceptions at runtime. To make this vision possible, we leverage two insights: (i) the vast majority of existing deadlocks occur between two threads attempting to acquire two locks (as reported by other authors~\cite{lu} and confirmed by us in Section~\ref{bugs}); and (ii) it is possible to efficiently introduce deadlock detection for these two-thread, two-lock deadlocks (TTTL deadlocks) within the locking mechanism itself, incurring in an overhead that is low for applications whose execution time is not dominated by locking. We present a new type of lock that automatically checks for TTTL deadlocks at runtime and, if one is found, throws an exception indicating the problem. We have implemented this approach as an extension to Java's {\tt ReentrantLock} class. Deadlock exceptions are already supported in programming languages such as Haskell \cite{marlow} and Go \cite{golang} but they focus on different types of deadlocks.

We present data from an empirical study showing that our assumption about the prevalence of TTTL deadlocks holds in practice. This confirms the findings of a previous study that focused on concurrency bugs in general~\cite{lu}. 
To evaluate our approach, we conducted two controlled experiments. In both cases, subjects using these new locks were able to detect deadlocks significantly faster than subjects not using them.  Furthermore, in one of the studies, this approach helped the subjects to more accurately identify the causes of the deadlock. We also show that our approach has an overhead that, while non-negligible, is low for applications whose execution time is not dominated by locking.

