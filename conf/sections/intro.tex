\section{Introduction}

Real-world applications use concurrency to do computation in parallel with multiple threads/processes taking more advantage of multicore processors. Unfortunately, concurrent code is difficult to write correctly, as it is well documented in \cite{lu}, and a very common mistake when using locks is known as deadlock.
Deadlocks manifest when threads are waiting each other in a cycle, where each thread is waiting for another thread to release its desired lock, in a never-ending wait.
Although we have two types of deadlocks, resource deadlocks and communication deadlocks \cite{singhal} \cite{knapp}, in this work our focus is on resource deadlocks, and whenever the term \emph{deadlock} is used we implicitly mean resource deadlock.

We believe deadlocks should not fail silently but instead they should be signaled as exceptions in programming languages. Some programming languages such as Haskell and Go already contain some kind of deadlock exception for very particular cases, and for this study, our proposed deadlock algorithm have focused on what we found to be the most common type of deadlock: between two threads and two locks (TTTL deadlocks).

Our main goals in this study are: to show how to detect TTTL deadlocks without extra atomic operations, providing a lightweight implementation of \emph{ReentrantLock} that dynamically detects TTTL deadlocks running seamlessly on top of Java OpenJDK; to evaluate the runtime overhead of such implementation; and, lastly, to understand the benefits of such exceptions in programming languages by evaluating how the speed and accuracy of bug identification are affected. We start this paper by describing our bug reports study where we found TTTL deadlocks were the most common type of deadlock. Then we move forward to describe how and why the deadlock algorithm works for TTTL deadlocks. Then we present our evaluation for both usability and performance.





